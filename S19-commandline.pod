=encoding utf8

=head1 TITLE

DRAFT: Synopsis 19: Command Line Interface


=head1 Author

Jerry Gay <jerry.gay@rakudoconsulting.com>


=head1 Version

  Maintainer: Jerry Gay <jerry.gay@rakudoconsulting.com>
  Date: 12 Dec 2008
  Last Modified: 4 Jan 2009
  Version: 10

This is a draft document. This document describes the command line interface.
It has changed extensively from previous versions of Perl in order to increase
clarity, consistency, and extensibility. Many of the syntax revisions are
extensions, so you'll find that much of the Perl 5 syntax embedded in your
muscle memory will still work.

Notable features described in the sections below include:

=over 4

=item *

A smart default command-line processor in the core

=item *

All options have a long, descriptive name for increased clarity

=item *

Common options have a short, single-letter name, and allow clustering

=item *

Extended option syntax provides the ability to set boolean true/false

=item *

New C<++> metasyntax allows options to be passed through to subsystems

=back

This interface to Perl 6 is special in that it occurs at the intersection of
the program and the operating system's command line shell, and thus is not
accessed via a consistent syntax everywhere. Perl is born of Unix, and as such
the syntax presented in this document is expected to work in a Unix-style
shell. To explore the particularities of other operating systems, see
L<Synopsis 25|S25-portability> (TBD).


[my notes/conjectures below are all in square brackets  --TimToady]

=head1 Command Line Elements

The command line is broken down into two basic elements: a I<program>, and
I<arguments>. Each command line element is whitespace separated, so elements
containing whitespace must be quoted. The I<program> processes the arguments
and performs the requested actions. It looks something like F</usr/bin/perl6>,
F<parrot perl6.pbc>, F<rakudo>, and is followed by zero or more I<arguments>.
Perl 6 does not do any processing of the I<program> portion of the command
line, but it is made available at run-time in the read-only C<$?PROGRAM>
variable.

Command line I<arguments> are broken down into I<options> and I<values>.
Each option may take zero or more values. After all options have been
processed, the remaining values (if any) generally consist of the name of a
script for Perl to execute, followed by arguments for that script. If no
values remain, Perl 6 reads the script from STDIN--you must specify the
special C<-> option if you wish to pass arguments to a script read from STDIN.


=head1 Backward (In)compatibility

Muscles have a long memory. You may find yourself typing your favorite Perl 5
options, even after Christmas has arrived. {{TODO}}

=head2 Unchanged Syntactic Features

Several features have not changed from Perl 5, including:

=over 4

=item *

The most common options have a single-letter short name

=item *

Single-letter options may be clustered with the same syntax and semantics

=item *

Many command-line options behave similarly, such as

  -a                                   # autosplit
  -c                                   # check syntax
  -e *line*                            # execute
  -F *expression*                      # specify autosplit value
  -h                                   # display help
  -I *directory*[,*directory*[,...]]   # add include paths
  -n                                   # act like awk
  -p                                   # act like sed
  -S                                   # search PATH for script
  -T                                   # Taint mode
  -v                                   # display version info
  -V                                   # display verbose config info

=back

=head2 Removed Syntactic Features

{{ -jg
need to tell a story about how perl 6 handles the migration from perl 5.
for example, if -0 is not a valid perl 6 command line option, how does perl 6
help the user realize and correct the mistake?
}}


=head1 Options and Values

Command line options are parsed using the following rules:

=over 4

=item *

Options must begin with one of the following symbols: C<< < -- - : > >>.

=item *

Options are case sensitive. C<-o> and C<-O> are not the same option.

=item *

All options have a multi-character, descriptive name for increased clarity.
Multi-character option names always begin with C<--> or C<:>.

=item *

Common options have a short, one-character name for speed.
Single-character names always begin with C<->.

=item *

Single-letter options may be clustered. C<-ab> means C<-a -b>. When a
single-letter option which requires a value is clustered, the option may
appear only in the final position of the cluster.

=item *

Options may be negated with C</>, for example C<--/name>, C<:/name>, C<-/n>.
Each single-letter option in a cluster must be negated separately
 (e.g. C<-a/n/o> is the same as C<-a -/n -/o>.)

=item *

Option names follow Perl 6 identifier naming convention, except C<'> is not
allowed, and single-letter options may be any letter or number.

=item *

The special option C<--> signals the parser to stop option processing.
Arguments following a bare C<--> (with no identifier) are always parsed as
a list of values, even if they look like valid options.

=back


Delimited options are a special form of option that are specified by
delimiters on either end, allowing options to be passed through to specified
subsystems, and are parsed with the following rules:

=over 4

=item *

The opening and closing delimiters begin with two or more plus characters,
for example C<++>. You'll usually use two plus characters, but more are
allowed to disambiguate (more below).

{{TODO put more below, or refer to somewhere with more}}

=item *

Opening and closing delimited option names follow option identifier naming
convention, defined above.

=item *

If the closing delimiter is omitted, the rest of the command line is consumed.

=item *

Inside a delimited option, the C<--> option does not suppress searching for
the closing delimiter.

=item *

Delimited options cannot be negated.

=back

[From the P6 viewpoint, these options should probably be shoved into
context variables and be invisible to MAIN except as %+OPTS<PARSER>
or @+PARSER_ARGS or some such.]

{{TODO %+OPTS it is. explain this.}}


Values are parsed with the following rules:

=over 4

=item *

Values containing whitespace must be enclosed in quotes, for example
C<-O="spacy val">

=item *

Values are passed to options with the following syntax C<--option=value>
or C<--option value>.

=item *

Multiple values are passed using commas without intervening whitespace,
as in C<--option=val1,'val 2',etc>

=back


=head1 Option Reference

Perl 6 options, descriptions, and services.

=head2 Synopsis

  multi sub perl6(
    Bool :a($autosplit),
    Bool :c($check-syntax),
    Bool :$doc,
         :e($execute),
         :F($autoloop-split),
    Bool :h($help),
         :I(@include),
         :u($use),
    Bool :n($autoloop-no-print),
         :O($output-format) = 'exe',
         :o($output-file) = $*OUT,
    Bool :p($autoloop-print),
    Bool :S($search-path),
    Bool :T($taint),
    Bool :v($version),
    Bool :V($verbose-config),
  );

=head2 Reference

=over 4

=item --autosplit, -a

Turns on autosplit mode.

=item ++CMD --command-line-parser *parser* ++/CMD

Add a command-line processor.  When this option is parsed, it immediately
triggers an action that affects or replaces the the command-line parser.
Therefore, it's a good idea to put this option as early as possible in the
argument list.

=item --check-syntax, -c

Check syntax, then exit.  Desugars to C<-e 'CHECK{ compiles_ok(); exit; }'>.

=item --doc

Lookup Perl documentation in Pod format.  Desugars to
C<-e 'CHECK{ compiles_ok(); dump_perldoc(); }'>. C<$+ARGS> contains the
arguments passed to C<perl6>, and is available at C<CHECK> time, so
C<dump_perldoc()> can respond to command-line options.

=item ++DEBUGGER [*switches*, *flags*] ++/DEBUGGER

Set debugging switches and flags.

Note: This is speculative, for lack of a debugger specification.

=item --execute, -e *line*

Execute a single-line program.  Multiple C<-e> options may be chained together,
each one representing an input line with an implicit newline at the end.

If you wish to run in lax mode, without strictures and warnings enabled,
pass a value of '6' to the first -e on the command line, like C<-e6>.
See L<Synopsis 11|S11-modules.pod/"Forcing Perl 6"> for details.

=item --autoloop-split, -F *expression*

Pattern to split on (used with -a).  Substitutes an expression for the default
split function, which is C<{split ' '}>.  Accepts unicode strings (as long as
your shell lets you pass them).  Allows passing a closure
(e.g. -F "{use Text::CSV}").  Awk's not better any more :)

=item --help, -h

Print summary of options.  Desugars to C<++CMD --print-help --exit ++/CMD>.

=item --include, -I *directory*[,*directory*[,...]]

Prepend directories to @*INC, for searching ad hoc libraries.  Searching the
standard library follows the policies laid out in L<S11-modules>.

=item --use, -u *module*

C<--use *module*> and C<-u *module*> desugars to C<-e 'use *module*'>.
Specify version info and import symbols by appending info to the module name:

  -u'Sense:ver<1.2.1>:auth<cpan:JRANDOM> <common @horse>'

You'll need the quotes so your shell doesn't complain about redirection.
There is no special command-line syntax for C<'no *module*>, use C<-e>.

=item --autoloop-no-print, -n

Act like awk.  Desugars to
C<++PARSER --prelude=Perl6-autoloop-no-print ++/PARSER>.

=item --output-format, -O *format*

Specify the file format for the output file requested with C<--output-file>.
This option is implementation-specific, so consult the documentation for your
Perl 6 implementation.

=item --output-file, -o [*filename*]

Compile to a file, rather than run immediately.  If no filename is specified,
STDOUT is used.  Specify the output format with C<--output-format>.

=item --autoloop-print, -p

Act like sed.  Desugars to
C<++PARSER --prelude=Perl6-autoloop-print ++/PARSER>.

=item --search-path, -S

Use PATH environment variable to search for script specified on command-line.

=item --taint, -T

Turns on "taint" checking. See L<Synopsis 23|S23-security.pod> for details.
Commits very early.  Put this option as early on the command-line as possible.

=item --version, -v

Display program name, version, patchlevel, etc.  Desugars to
C<++CMD -v ++/CMD ++PARSER -v ++/PARSER ++DEBUGGER -v ++/DEBUGGER>.

=item --verbose-config, -V

Display configuration details.  Desugars to
C<++CMD -V ++/CMD ++PARSER -V ++/PARSER ++DEBUGGER -V ++/DEBUGGER>.

=back


=head1 Metasyntactic Options

Metasyntactic options are a subset of delimited options used to pass arguments
to an underlying component of Perl. Perl itself does not parse these options,
but makes them available to run-time components via the C<%+META-ARGS> context
variable.

Standard in Perl 6 are three underlying components, C<CMD>, C<PARSER>,
and C<DEBUGGER>.  Implementations may expose other components via this
interface, so consult the documentation for your Perl 6 implementation.

{{TODO more description and examples}}

  On command line...                   Subsystem gets...
   ++X a -b  ++/X                      a -b

  # Nested options
  +++X a -b   ++X -c ++/X -d e +++/X   a -b ++X -c ++/X -d e

  # More than once
   ++X a -b  ++/X -c  ++X -d e  ++/X   a -b -d e
  +++X a -b +++/X -c  ++X -d e  ++/X   a -b -d e


=head1 Environment Variables

Environment variables may be used to the same effect as command-line
arguments.

=over 4

=item PATH

Used in executing subprocesses, and for finding the program if the -S switch
is used.

=item PERL6LIB

A list of directories in which to look for Perl library files.

Note: this is speculative, as library loading is not yet specified.

[except insofar as S11 mandates various behaviors incompatible with
mere directory probing...]

=item PERL6OPT

Default command-line arguments. Arguments found here are prepended to the
list of arguments provided on the command-line.

=back


=head1 References

=over 4

=item L<http://perldoc.perl.org/perlrun.html>

=item L<http://search.cpan.org/~jv/Getopt-Long-2.37/lib/Getopt/Long.pm>

=item L<http://search.cpan.org/~dconway/Getopt-Euclid-v0.2.0/lib/Getopt/Euclid.pm>

=item L<http://perlcabal.org/syn/S06.html#Declaring_a_MAIN_subroutine>

=item L<http://search.cpan.org/src/AUDREYT/Perl6-Pugs-6.2.13/docs/Pugs/Doc/Run.pod>

=item L<http://haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html>

=item L<http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html>

=back


=head1 Notes

{{ -jg
i'd like to be able to adjust the input record separator from command line,
for instance to specify the equivalent of perl 5's C<$/ = \32768;>. so far,
i don't have a solution, but perhaps pass a closure that evaluates to an int?

[this should try to use whatever option does the same thing to a new
filehandle when S16 is further developed.]

do i need to address any unicode concerns?

[You can try "all command line arguments are assumed to be in unicode
unless proven otherwise" and see how well it flies. :)  but this starts
to get into filenames-are-blobs kind of issues...maybe we need a way
of marking arguments as needing to be encoded into a Buf.  but for sanity
we must try to settle on unicode as the default expectation.  I hope POSIX
dies before Perl 6 does...]

loading a switch parsing module by a switch, instead of using the default.
maybe via ++RTS, since it needs to happen *before* switches are evaluated.

[suggest ++CMD --use_cmd_module ++/CMD]

sandboxing? maybe-r

env var? maybe -E

[could be posed in terms of substituting a different prelude]
}}

=for vim:set expandtab sw=4:
