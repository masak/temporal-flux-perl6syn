=encoding utf8

=head1 TITLE

DRAFT: Synopsis 19: Command Line Interface


=head1 Author

Jerry Gay <jerry.gay@rakudoconsulting.com>


=head1 Version

  Maintainer: Jerry Gay <jerry.gay@rakudoconsulting.com>
  Date: 12 Dec 2008
  Last Modified: 30 Dec 2008
  Version: 5

This is a draft document. This document describes the command line interface.
It has changed extensively from previous versions of Perl in order to increase
clarity, consistency, and extensibility. Many of the syntax revisions are
extensions, so you'll find that much of the Perl 5 syntax embedded in your
muscle memory will still work.

Notable features described in the sections below include:

=over 4

=item *

A much smarter default command-line processor in the core

=item *

All options have a long, descriptive name for increased clarity

=item *

Common options have a short, single-letter name, and allow bundling

=item *

Extended option syntax provides the ability to set boolean true/false

=item *

New C<++> metasyntax allows options to be passed through to subsystems

=back

This interface to Perl 6 is special in that it occurs at the intersection of
the program and the operating system's command line shell, and thus is not
accessed via a consistent syntax everywhere. Perl is born of Unix, and as such
the syntax presented in this document is expected to work in a Unix-style
shell. To explore the particularities of other operating systems, see
L<Synopsis 25|S25-portability> (TBD).


[my notes/conjectures below are all in square brackets  --TimToady]

=head1 Command Line Elements

The command line is broken down into two basic elements: a I<program>, and
I<arguments>. Each command line element is whitespace separated, so elements
containing whitespace must be quoted. The I<program> processes the arguments
and performs the requested actions. It looks something like F</usr/bin/perl6>,
F<parrot perl6.pbc>, F<rakudo>, and is followed by zero or more I<arguments>.
Perl 6 does not do any processing of the I<program> portion of the command
line, but it is made available at run-time in the read-only C<$?PROGRAM>
variable.

Command line I<arguments> are further broken down into I<options> and
I<values>. Unlike Perl 5, I<options> and I<values> may be intermixed on the
command line. This mirrors the Perl 6 argument syntax for Routines, which
allows named and positional parameters to be intermixed. The recommendation
for parameter ordering applies here as well, with a slight twist: keep all
command line options together, even though this is not enforced, in order to
avoid confusion.

[ This policy may be counter-intuitive to current comand-line cultures. ]

{{ 'ack' is a notable exception to the old rule, and i like the freedom.
besides, perl 6 is about looking forward, and creating a new culture. :)
on the other hand, i won't fight to keep this if it doesn't get support. }}


=head1 Backward (In)compatibility

Muscles have a long memory. You may find yourself typing your favorite Perl 5
options, even after Christmas has arrived. {{TODO}}

=head2 Unchanged Syntactic Features

{{TODO short names, bundling, etc}}

=head2 Removed Syntactic Features

{{ -jg
need to tell a story about how perl 6 handles the migration from perl 5.
for example, if -0 is not a valid perl 6 command line option, how does perl 6
help the user realize and correct the mistake?
}}


=head1 Options and Values

Command line options are parsed using the following rules:

=over 4

=item *

Options must begin with one of the following symbols: C<< < -- - + : > >>.

=item *

Options are case sensitive. C<-o> and C<-O> are not the same option.

=item *

All options have a multi-character, descriptive name for increased clarity.
Multi-character option names always begin with C<-->, C<+>, or C<:>.

=item *

Common options have a short, one-character name for speed.
Single-character names always begin with C<->.

=item *

Single-letter options may be clustered. C<-ab> means C<-a -b>.

=item *

Option names follow Perl 6 identifier naming convention, but C<'>
is not allowed.

=item *

Options may be negated with C</> or C<!>, for example C<:/name>

[:/name reminds me more of an end tag than a negated, but I see
why you want it, given the history of history characters...interestingly,
:0name has the same effect in current p6, since we generalized :3x
and such.]

{{ dunno how TIMTOWTDI i want to get here, so i haven't changed the text
above, but have standardized on C</> below. }}

=item *

The special option C<--> signals the parser to stop option processing.
Arguments following a bare C<--> (with no identifier) are always parsed as
a list of values, even if they look like valid options.

=back


Delimited options are a special form of option that are specified by
delimiters on either end, allowing options to be passed through to specified
subsystems, and are parsed with the following rules:

=over 4

=item *

The opening and closing delimiters begin with two or more plus characters,
for example C<++>. You'll usually use two plus characters, but more are
allowed to disambiguate (more below).

{{TODO put more below, or refer to somewhere with more}}

=item *

Opening and closing delimited option names follow option identifier naming
convention, defined above.

=item *

If the closing delimiter is omitted, the rest of the command line is consumed.

=item *

Inside a delimited option, the C<--> option does not suppress searching for
the closing delimiter.

=item *

Delimited options cannot be negated.

=back

[From the P6 viewpoint, these options should probably be shoved into
context variables and be invisible to MAIN except as %+OPTS<PARSER>
or @+PARSER_ARGS or some such.]

{{TODO %+OPTS it is. explain this.}}


Values are parsed with the following rules:

=over 4

=item *

Values containing whitespace must be enclosed in quotes, for example
C<-O="spacy val">

=item *

Values are passed to options with the following syntax C<--option=value>
or C<--option value>.

=item *

Multiple values are passed using commas without intervening whitespace,
as in C<--option=val1,'val 2',etc>

=back


These rules have been quantified in the following grammar, used solely for
illustration purposes (this is *not* how options will be parsed by any shell).

{{TODO update to current, move to non-published helper doc}}

  grammar CommandLineArguments;

  rule TOP {
      <argument>*
      '--'?
      $<rest>=[.*]?
      [ $ || <panic: 'Syntax error'> ]
  }

  rule argument { [ <option> | <passthru> | <value> ] {*} }

  token option {
      [
        [
          $<sym>=[ '--' | '-' | '+' | ':' ]
          $<neg>=[ '!' | '/' ]?
          <name>
        ]
        [ '=' <value> [ ',' <value> ]* ]?
      ]
  }

  regex passthru {
      '++' <indicator> <.ws>
      $<data>=[.*?]
      [ '--' $<indicator> || $ ]
  }

  token indicator { <name> [ '=' <target=name> ]? }

  token name { <.ident> [ '-' <.ident> ]* }

  token value {
      | (\w+)
      | \' (<-[\']>*) \'
      | \" (<-[\"]>*) \"
  }


=head1 Option Categories

Perl's command line options fall into three categories:

=over 4

=item *

B<Mode> flags set Perl's operational mode (e.g. I<--doc>, I<-e>).
Only one mode flag may be specified on the command line.

=item *

B<Dynamic> flags may be set on the command line, via the I<PERL6OPT>
environment variable, or within a file.

[What file?  We need to be Very Careful not to delegate the identity of
the current language to anything outside of P6.  I would very much hate
to see anything resembling a .perl6rc file.]

{{ TODO clarify that i mean "source file" here and not an rc-like file }}

=item *

B<Static> flags may be set only on the command line, and affect the entire
run of the program.

[I think this Static/Dynamic distinction is rather meaningless and
confusing.  Certain commitments will be made by certain phases of
compilation/linking/running, and every switch is dynamic before the
commitment, static after.  And Mode flags are just the ones that
commit so fast they exclude alternatives, seems like...]

{{TODO very well, i'll shift the design to be more dynamic here}}

=back

For more on options and their classifications, see section
L</"Option Reference">.


=head1 Option Services

Just because Perl 6 gives you a reasonable default command-line parser doesn't
mean you don't want to extend it, or replace it with something else entirely.
The command-line processor is organized into a set of services, each of which
respond to a set of command-line options. These services live in the
C<{{TODO}}> namespace, and may be overridden by loading a module with the
C<--option-parser> option (see below).

{{ TODO more details needed }}

[Would like to see a use case for this mechanism.  The whole Services
concept seems very nebulous, especially when you start giving services
names like "Awk"..."Autoloop" would be more meaningful.]

{{rename done}}

=head1 Option Reference

Perl 6 options, descriptions, categories, and services

=over 4

=item --autosplit, -a

Turns on autosplit mode.

Service: Autoloop

Notes: Annotates function produced by -n | -p

=item ++ARGSPROC [options, values] ++/ARGSPROC

{{TODO don't like this name, but don't like ++CMD either}}

Add a command-line processor.

Service: Option

Notes: When this option is parsed, it immediately triggers an action that
could affect the remainder of the parse. Therefore, it's a good idea to put
this option as early as possible in the argument list.

{{TODO more details needed}}


=item --check-syntax, -c

Check syntax, then exit.

Service: Runtime

Notes: Desugars to C<++COMPILER -e 'CHECK{ compiles_ok(); exit; }' ++/COMPILER>

=item --doc

perldoc

Service: Doc

Notes: Desugars to
C<++COMPILER -e 'CHECK{ compiles_ok(); dump_perldoc(); }' ++/COMPILER>

{{TODO what do i pass to dump_perldoc? C<$+ARGS>, maybe?}}

=item ++DEBUGGER [switches, flags] ++/DEBUGGER

Set debugging flags.

Service: Debugger

Notes: At least it's a start. Need a debugger spec for more.

=item --execute, -e commandline

Execute a single-line program. Multiple C<-e> options may be chained together,
each one representing an input line with an implicit newline at the end.

Service: Runtime

Notes: Returns a function that's executed unless otherwise modified by
Autoloop service's -p , -n, -a, -F.
Actually combines all source from all -e parameters, then compiles when
there are no more -e. Assigns the generated function to MAIN.

[Not really a Mode in the sense you've defined it, but an input
redirection of a vaguely here-docish flavor.  You could combine it
with -c or --doc for instance, so not exclusive.]

=item --execute-lax, -e6

Execute in lax mode, without strictures and warnings enabled.
See L<Synopsis 11|S11-modules.pod/"Forcing Perl 6"> for details.

Service: Runtime

=item --autoloop-split, -F [string, closure, etc]

Pattern to split on (used with -a). Accepts unicode strings (as long as your
shell lets you pass them). Allows passing a closure
(e.g. -F "{use Text::CSV}"). Awk's not better any more :)

Service: Autoloop

Notes: Substitutes a function for the default function which
is { split ' ' } or whatever.

=item --help, -h

Print summary of options. Desugars to C<++CMD --print-help --exit ++/CMD>.

Service: Usage

=item --include, -I

Prepend directory to @*INC.

Service: Lib

Notes: this is unspecced elsewhere, so may not survive long.

[at best, @*INC will only be the user's ad hoc libraries.  The API for
searching the standard lib will not be defined in terms of @*INC so that
we can enforce the standard library policies laid out in S11.]

=item -m[-]module, -M[-]module, -M[-]'module ...', -[mM][-]module=arg[,arg]...

{{TODO needs new or extended syntax}}

use/no module.

Service: Meta

Notes: Maybe this happens before or affects which services are loaded.
Or maybe there can be a UNIVERSAL service which knows about other services
and is built into the interpreter. No looking at disk required?

[I have no idea what you're talking about here...these switch are in
the same category as -n and -p; they imply additional wrapping of
the given code with extra "use" directives.  The syntax could probably
use some refactoring though.]

=item --autoloop-no-print, -n

Act like awk.

Service: Autoloop

Notes: Desugars to C<++PARSER --prelude=Perl6-autoloop-no-print ++/PARSER>.

=item --output-format, -O [format]

Specify the file format for the output file requested with C<--output-file>.
Defaults to 'exe', which represents the target platform's idea of an
executable. Other valid values are implementation-specific, so consult the
documentation for your compiler toolchain.

=item --output-file, -o [filename]

Compile to a file, rather than run immediately. If no filename is specified,
STDOUT is used. Specify the output format with C<--output-format>.

=item --autoloop-print, -p

Act like sed.

Service: Autoloop

Notes: Desugars to C<++PARSER --prelude=Perl6-autoloop-print ++/PARSER>.

=item --search-path, -S

Use path to search for program.

Service: Runtime

[you need a story for when the first argument is treated as
the program name. e.g. when you *don't* use -e to supply the program.]

=item --taint, -T

Turns on "taint" checking. See L<...> for details.

Notes: Commits very early. Recommend putting this option as early on the
command-line as possible.

=item --version, -v

Display program name, version, patchlevel, etc.

Service: Usage

[maybe wants to propagate -v to ++CMD, ++PARSER, ++RTS, and any
other known subsystems?]

[or maybe -v is ++TOWHOMITMAYCONCERN --print_version_and_exit]

{{TODO}}

=item --verbose-config, -V

Display configuration details.

Service: Usage

[likewise]

=back


=head1 Run-time System

{{TODO total rewrite needed}}

The run-time system delimited option (C<++RTS ... ++/RTS> or
C<++RTS=string ... ++/RTS=string>) allows options to be passed to an underlying
component of Perl. Perl itself does not parse these options, but makes them
available to run-time components.

[Note that with my proposed system you can still nest without the artificial =:
    ++RTS ++GC -generational ++/GC ++/RTS
]

The C<=string> variation allows for disabmiguation when the run-time system
also allows the parsing of an option named C<++RTS>. For example,
C<perl ++RTS=outer -a :b +C --RTS foo bar ++/RTS=outer>
makes sure the run-time system receives C<-a :b +C --RTS foo bar>.

Additionally, some implementations may use this variation to pass arguments
to particular subsystems. For example, Rakudo Perl may choose to implement
C<perl ++RTS=parrot --runcore=gc-debug -t 7 ++/RTS=parrot ++RTS=PGE --disable-keepall --optimize ++/RTS=PGE>
to mean C<--runcore=gc-debug -t 7> gets passed to parrot, and
C<--disable-keepall --optimize> gets passed to PGE.

[perl ++PARROT --runcore=gc-debug -t 7 ++/PARROT ++PGE --disable-keepall --optimize ++/PGE>

{{ -jg
should certain string prefixes or perhaps uppercase strings be reserved
for this purpose?
}}

[doesn't seem very necessary, if we make sure ++ has its own namespace.  currently
that namespace is quite barren.  we wouldn't even necessarily need to enforce uppercase,
since

    perl ++parrot --runcore=gc-debug -t 7 ++/parrot ++pge --disable-keepall --optimize ++/pge

is just about as readable, especially if written:

    perl ++parrot --runcore=gc-debug -t 7 ++/parrot \
        ++pge --disable-keepall --optimize ++/pge \
        foo bar baz


or some such.]


=head1 Environment Variables

Environment variables may be used to the same effect as command-line
arguments.

=over 4

=item PATH

Used in executing subprocesses, and for finding the program if the -S switch
is used.

=item PERL6LIB

A list of directories in which to look for Perl library files.

Note: this is speculative, as library loading is not yet specified.

[except insofar as S11 mandates various behaviors incompatible with
mere directory probing...]

=item PERL6OPT

Default command-line arguments. Arguments found here are prepended to the
list of arguments provided on the command-line.

=back


=head1 References

=over 4

=item L<http://perldoc.perl.org/perlrun.html>

=item L<http://search.cpan.org/~jv/Getopt-Long-2.37/lib/Getopt/Long.pm>

=item L<http://search.cpan.org/~dconway/Getopt-Euclid-v0.2.0/lib/Getopt/Euclid.pm>

=item L<http://perlcabal.org/syn/S06.html#Declaring_a_MAIN_subroutine>

=item L<http://search.cpan.org/src/AUDREYT/Perl6-Pugs-6.2.13/docs/Pugs/Doc/Run.pod>

=item L<http://haskell.org/ghc/docs/latest/html/users_guide/using-ghc.html>

=item L<http://java.sun.com/j2se/1.4.2/docs/tooldocs/windows/java.html>

=back


=head1 Notes

{{ -jg
i'd like to be able to adjust the input record separator from command line,
for instance to specify the equivalent of perl 5's C<$/ = \32768;>. so far,
i don't have a solution, but perhaps pass a closure that evaluates to an int?

[this should try to use whatever option does the same thing to a new
filehandle when S16 is further developed.]

do i need to address any unicode concerns?

[You can try "all command line arguments are assumed to be in unicode
unless proven otherwise" and see how well it flies. :)  but this starts
to get into filenames-are-blobs kind of issues...maybe we need a way
of marking arguments as needing to be encoded into a Buf.  but for sanity
we must try to settle on unicode as the default expectation.  I hope POSIX
dies before Perl 6 does...]

loading a switch parsing module by a switch, instead of using the default.
maybe via ++RTS, since it needs to happen *before* switches are evaluated.

[suggest ++CMD --use_cmd_module ++/CMD]

sandboxing? maybe-r

env var? maybe -E

[could be posed in terms of substituting a different prelude]
}}

=for vim:set expandtab sw=4:
