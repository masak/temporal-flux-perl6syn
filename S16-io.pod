
=encoding utf8

=head1 Title

DRAFT: Synopsis 16: IPC / IO / Signals

=head1 Version

 Author:        Largely, the authors of the related Perl 5 docs.
 Maintainer:    Larry Wall <larry@wall.org>
 Contributions: Mark Stosberg <mark@summersault.com>
                Tim Nelson <wayland@wayland.id.au>
                Daniel Ruoso <daniel@ruoso.com>
 Date:          12 Sep 2006
 Last Modified: 23 Feb 2009
 Version:       21

This is a draft document. Many of these functions will work as in Perl
5, except we're trying to rationalize everything into roles.  For
now you can assume most of the important functions will automatically
be in the * namespace.  However, with IO operations in particular,
many of them are really methods on an IO handle, and if there is a
corresponding global function, it's merely an exported version of
the method.

=head1 Overridable IO handles

In Perl 6, there are the I<standard> IO handles, and any number of overriding
inner filehandles for the same symbol.  

The I<standard> handles are our old familiar friends (with new names).
Standard input changed from STDIN to C<$*IN>, standard output changed
from STDOUT to C<$*OUT>, and standard error changed from STDERR to
C<$*ERR>.  In Perl 6 these symbols represent more of a concept than
a given filehandle, since the meaning is contextually determined.
The process's version of these handles live in the C<PROCESS::>
namespace, which is more global than the per-interpreter C<GLOBAL::>
namespace.

When no explicit filehandle is used, the standard IO operators are
defined in terms of the contextual variables.  So the C<print> function
prints to C<$*OUT>, while C<warn> warns to C<$*ERR>.  The C<< =<> >>
term inputs from C<$*IN>.  So any given dynamic scope (interpreter,
thread, function or method call) may redefine the current meaning of
any of those filehandles within the dynamic scope of itself and of
its called routines.

So to put it another way, when you write something like

    say "Howdy, world!"

the C<say> function looks for the current meaning of C<$*OUT>, and
takes the closest definition it can find in its callers.  If none
of the callers have overridden the definition, it looks in the
interpreter's C<GLOBAL> namespace.  If the interpreter hasn't overridden
the meaning, it takes the meaning from C<PROCESS>.  In essence, any
dynamic scope in Perl 6 is allowed to do IO redirection much like
a Unix shell does with its subprocesses, albeit with a different
syntax:

    {
	temp $*OUT = open $newfile, :w;
	foo() # all stdout goes to $newfile
    }
    # stdout reverts to outer scope's definition

=head1 Roles and Classes

The roles and classes that define most of the functionality for IO are defined in 
S32-setting-library/IO.pod.  The main functions used are listed in S29 with references to 
S32-setting-library/IO.pod.  

=head1 POSIX Signals

The %*SIG variable contains a Hash of Proc::Signals::Signal.  

class	Signal {
	has $exception; # This specifies what exception will be raised when this signal is received
	has $interrupt; # See siginterrupt(3)
	has $blocked;   # Is this signal blocked?  cf. sigprocmask
}

The @*SIGQUEUE array contains a queue of the signals that are blocked and queued.  

The standard POSIX signals simply raise control exceptions that are handled as normal 
through the control signal handler, and caught by CONTROL blocks.  

=head2 Signal defaults

The signals have defaults as specified in the table below.  $blocked always defaults to 
false.  

 Signal     Default Exception
 ------     -----------------
 SIGHUP     ControlExceptionSigHUP
 SIGINT     ControlExceptionSigINT
 SIGQUIT    ControlExceptionSigQUIT
 SIGILL     ControlExceptionSigILL
 SIGABRT    ControlExceptionSigABRT
 SIGFPE     ControlExceptionSigFPE
 SIGKILL    ControlExceptionSigKILL
 SIGSEGV    ControlExceptionSigSEGV
 SIGPIPE    ControlExceptionSigPIPE
 SIGALRM    ControlExceptionSigALRM
 SIGTERM    ControlExceptionSigTERM
 SIGUSR1    ControlExceptionSigUSR1
 SIGUSR2    ControlExceptionSigUSR2
 SIGCHLD    undef
 SIGCONT    ControlExceptionSigCONT
 SIGSTOP    ControlExceptionSigSTOP
 SIGTSTP    ControlExceptionSigTSTP
 SIGTTIN    ControlExceptionSigTTIN
 SIGTTOU    ControlExceptionSigTTOU
 SIGBUS     ControlExceptionSigBUS
 SIGPROF    ControlExceptionSigPROF
 SIGSYS     ControlExceptionSigSYS
 SIGTRAP    ControlExceptionSigTRAP
 SIGURG     undef
 SIGVTALRM  ControlExceptionSigVTALRM
 SIGXCPU    ControlExceptionSigXCPU
 SIGXFSZ    ControlExceptionSigXFSZ
 SIGEMT     ControlExceptionSigEMT
 SIGSTKFLT  ControlExceptionSigSTKFLT
 SIGIO      ControlExceptionSigIO
 SIGPWR     ControlExceptionSigPWR
 SIGLOST    ControlExceptionSigLOST
 SIGWINCH   undef

=head2 Signal exceptions

A table below describes the exceptions.  

Each of these has a default action as well.  The possible actions are:

 Term   Default action is to terminate the process.

 Ign    Default action is to ignore the signal ($signal.exception is undef by default)

 Core   Default action is to terminate the process and dump core (see core(5)).

 Stop   Default action is to stop the process.

 Cont   Default action is to continue the process if it is currently stopped.

Some actions do the Resumeable role.  An exception listed in the table below that does the 
Resumeable role is marked with a * in the R column.  

The exceptions are:

 Signal                   Action   R Comment
 ----------------------------------------------------------------------
 ControlExceptionSigHUP    Term    ? Hangup detected on controlling terminal or death of controlling process
 ControlExceptionSigINT    Term    ? Interrupt from keyboard
 ControlExceptionSigQUIT   Core    ? Quit from keyboard
 ControlExceptionSigILL    Core    ? Illegal Instruction
 ControlExceptionSigABRT   Core    ? Abort signal from abort(3)
 ControlExceptionSigFPE    Core    ? Floating point exception
 ControlExceptionSigKILL   Term    ? Kill signal
 ControlExceptionSigSEGV   Core      Invalid memory reference
 ControlExceptionSigPIPE   Term    ? Broken pipe: write to pipe with no readers
 ControlExceptionSigALRM   Term    ? Timer signal from alarm(2)
 ControlExceptionSigTERM   Term    ? Termination signal
 ControlExceptionSigUSR1   Term    ? User-defined signal 1
 ControlExceptionSigUSR2   Term    ? User-defined signal 2
 ControlExceptionSigCHLD   Ign     ? Child stopped or terminated
 ControlExceptionSigCONT   Cont    * Continue if stopped
 ControlExceptionSigSTOP   Stop    ? Stop process
 ControlExceptionSigTSTP   Stop    ? Stop typed at tty
 ControlExceptionSigTTIN   Stop    ? tty input for background process
 ControlExceptionSigTTOU   Stop    ? tty output for background process
 ControlExceptionSigBUS    Core    ? Bus error (bad memory access)
 ControlExceptionSigPROF   Term    ? Profiling timer expired
 ControlExceptionSigSYS    Core    ? Bad argument to routine (SVr4)
 ControlExceptionSigTRAP   Core    ? Trace/breakpoint trap
 ControlExceptionSigURG    Ign     ? Urgent condition on socket (4.2BSD)
 ControlExceptionSigVTALRM Term    ? Virtual alarm clock (4.2BSD)
 ControlExceptionSigXCPU   Core    ? CPU time limit exceeded (4.2BSD)
 ControlExceptionSigXFSZ   Core    ? File size limit exceeded (4.2BSD)
 ControlExceptionSigEMT    Term    ?
 ControlExceptionSigSTKFLT Term    ? Stack fault on coprocessor (unused)
 ControlExceptionSigIO     Term    ? I/O now possible (4.2BSD)
 ControlExceptionSigPWR    Term    ? Power failure (System V)
 ControlExceptionSigLOST   Term    ? File lock lost
 ControlExceptionSigWINCH  Ign     ? Window resize signal (4.3BSD, Sun)

See L<S04-control> for details on how to handle exceptions.  

XXX I'm unsure how the actions in the table above can be made to make sense.  The Ign 
actions are already dealt with because %SIG{CHLD}.exception already defaults to undef.  
The Term action will probably be self-solving (ie. will terminate the process).  The 
others I'm just plain unsure about.  XXX


=head1 Additions

Please post errors and feedback to perl6-language.  If you are making
a general laundry list, please separate messages by topic.

=cut
