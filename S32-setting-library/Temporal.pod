
=encoding utf8

=head1 Title

DRAFT: Synopsis 32: Setting Library - Temporal

=head1 Version

 Author:        Rod Adams <rod@rodadams.net>, the authors of the related Perl 5 docs.
 Maintainer:    Larry Wall <larry@wall.org>
 Contributions: Aaron Sherman <ajs@ajs.com>
                Mark Stosberg <mark@summersault.com>
                Carl MÃ¤sak <cmasak@gmail.com>
                Moritz Lenz <moritz@faui2k3.org>
                Tim Nelson <wayland@wayland.id.au>
                Daniel Ruoso <daniel@ruoso.com>
 Date:          19 Mar 2009 extracted from S29-functions.pod and S16-IO.pod
 Last Modified: 19 Feb 2009
 Version:       1

The document is a draft.

If you read the HTML version, it is generated from the pod in the pugs 
repository under /docs/Perl6/Spec/S32-setting-library/Temporal.pod so edit it there in
the SVN repository if you would like to make changes.

=head2 Time

=over

=item gmtime

 our Time multi gmtime ( Time $time? )
 our Time multi method gmtime ( Time $time: )

Identical to:

 Time::localtime(:$time,:tz<GMT>)

=item localtime

 our Time multi localtime ( Time $time?, Time::Zone $tz? )
 our Time multi method localtime ( Time $time: Time::Zone $tz? )

Returns a time object whose default timezone is C<$tz> (or the system's
default timezone if none is provided).

If used as a function, and no time is provided, the current time is used.

Note that no matter what, C<$time>'s concept of "its timezone" is discarded
in favor of something new.

=item time

 our Time multi time()

Returns a C<Time> object. There are a number of uses for this
object, all of which can be found in the documentation for C<Time>.

There is, by default, no timezone associated with this Time object, so
whatever default the system has will take over if timezone-specific
data is accessed.

=back

=head1 Roles

=head2 Time and Date roles

=head3 Date

You probably want to use the DateTime object instead.  

role	Date {
	has Calendar $.calendar; # Gregorian, Secular, Julian, etc
	has NumberName $.year;
	has NumberName $.month;
	has NumberName $.dayofmonth;
	has NumberName $.dayofweek;
	has NumberName $.dayofyear;
	has NumberName $.dayofquarter;
	has NumberName $.quarter;
	has NumberName $.era; # 'Common', 'Christian', etc
	has Str $.defaultformat;

	method	toString($format);
	method	isLeapYear();

	multi method DateTime infix:<+>(Date $self, Time $other);
	multi method DateTime infix:<+>(Date $self, Duration $other);

	multi method infix:{'<=>'}(Date $self, Date $other);
	multi method infix:{'<=>'}(Date $self, Duration $other);

	method	get(Str $type, Str $of);
	method	last(Str $type, Str $of);
}

Example:

$date = new Date('2002/01/01');
$date.month.name(); # January
$date.month.name('short'); # Jan
$date.get('day', of => 'year');

$date = new Date('2002/01/01');
$date.convertcalendar('Chinese');
$date.year.name(); # Snake

A fair bit of initialisation of the NumberNames for day of the week and month will need to 
be done.  

$format will naturally need to allow for eras.  

=over

=item 

 method toString($format = 'YYYY/MM/DD');

$format contains things like YYYY/MM/DD or whatever.  

=back

=head3 Time

You probably want to use the DateTime object instead.  

role	Time {
	has $.hour;
	has $.minute;
	has $.second;

	method	toString($format?);
	# This can't be right; how do we specify this
	multi method infix:{'<=>'}(Time $self, Time $other);
	multi method infix:{'<=>'}(Time $self, Duration $other);
}

When created, recognises "today" as a possibility.  

=head1 Classes

=head2 Time and Date classes

=head3 NumberName

 class	NumberName {
	has $.number;

	method	name($format?) {
		...
	}
 }

=head3 Timezone

role Timezone {
	has $.number;

	method name($format);
	method is_dst();
}

=head3 DateTime

class	DateTime does Date does Time does Timezone {
	has $.locale;
	has $.parser;
	has $.formatter; # Only for output formats

	multi method DateTime infix:<+>(DateTime $self, Duration $other);

	multi method infix:<->(DateTime $self, Duration $other);
	multi method infix:<->(DateTime $self, Duration $other);

	multi method infix:{'<=>'}(DateTime $self, DateTime $other);
	multi method infix:{'<=>'}(DateTime $self, Duration $other);

	method	new(:$String);
	method	truncate(Str $to);
	method	last(Str $type, Str $of);
	method	toString($format?);
}

All formats are CLDR, although implementations may want to have another set of functions 
that use the strftime functions instead.  

=over

=item new

 method new(Str :$String) # parser defaults to 'strptime' or something similar
	| (Str $parser, Str $String) # $parser = 'strptime'
	| (Str $parser, Int $Epoch)  # $parser = 'epoch'
	| (Str $parser, Str $Timezone?) # $parser = 'today' [unless strptime does this]
	;

Tries to parse the date and time specified using $parser.  

If $Epoch is passed in instead, then it interprets the time as being in seconds since the 
epoch (which is determined on a system-by-system basis).

If $parser is 'today', then the current time is gotten.  Timezone would be useful for 
simulating eg. gmtime().  

=item	truncate

Can be used to truncate a function to the current day, or whatever.  

=item	last

 $date.last('day', of => 'month');

=back

=head3 Duration

=head3	Repetition

This class specifies when a repetitive action (eg. a cron job) happens.  

class	DateTime::Recurring {
...
}

Should allow creation from the format that cron uses (ie. */5 * * * * ).  

=head1 Additions

Please post errors and feedback to perl6-language.  If you are making
a general laundry list, please separate messages by topic.

